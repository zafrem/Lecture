#!/usr/bin/env python3
"""
Vulnerability Assessment & Penetration Testing Examples
-----------------------------------------------------
This script demonstrates basic vulnerability assessment concepts in Python:
1. Simple web vulnerability scanner (XSS, SQLi detection)
2. Basic password strength checker
3. File integrity monitoring
4. Simple security headers checker
"""

import re
import os
import hashlib
import time
import urllib.parse
import requests
from bs4 import BeautifulSoup
from urllib.parse import urlparse, urljoin
from datetime import datetime

# ---- 1. Web Vulnerability Scanner ----

class WebVulnScanner:
    """Simple web vulnerability scanner to detect common web vulnerabilities"""
    
    def __init__(self, base_url, max_urls=10):
        """Initialize with the target URL"""
        self.base_url = base_url
        self.max_urls = max_urls  # Limit URLs to scan for the demo
        self.visited_urls = set()
        self.urls_to_visit = [base_url]
        self.forms = []
        self.vulnerabilities = []
        
        # Parse base URL to restrict crawling to same domain
        parsed_url = urlparse(base_url)
        self.domain = parsed_url.netloc
    
    def crawl(self, max_depth=2):
        """Crawl website to find forms and links"""
        print(f"Crawling {self.base_url} (limited to {self.max_urls} URLs)...")
        
        depth = 0
        while self.urls_to_visit and len(self.visited_urls) < self.max_urls and depth < max_depth:
            url = self.urls_to_visit.pop(0)
            
            if url in self.visited_urls:
                continue
                
            print(f"Visiting: {url}")
            
            try:
                response = requests.get(url, timeout=5)
                self.visited_urls.add(url)
                
                if response.status_code == 200 and 'text/html' in response.headers.get('Content-Type', ''):
                    # Extract forms
                    self._extract_forms(url, response.text)
                    
                    # Extract links for further crawling
                    soup = BeautifulSoup(response.text, 'html.parser')
                    for a_tag in soup.find_all('a', href=True):
                        href = a_tag['href']
                        full_url = urljoin(url, href)
                        
                        # Only follow links on the same domain
                        if urlparse(full_url).netloc == self.domain and full_url not in self.visited_urls:
                            self.urls_to_visit.append(full_url)
            
            except requests.RequestException as e:
                print(f"Error requesting {url}: {e}")
                
            depth += 1
            
        print(f"Crawling completed. Found {len(self.forms)} forms across {len(self.visited_urls)} pages")
    
    def _extract_forms(self, url, html_content):
        """Extract forms from HTML content"""
        soup = BeautifulSoup(html_content, 'html.parser')
        found_forms = soup.find_all('form')
        
        for form in found_forms:
            form_info = {
                'url': url,
                'method': form.get('method', 'get').lower(),
                'action': urljoin(url, form.get('action', '')),
                'inputs': []
            }
            
            # Extract form inputs
            for input_field in form.find_all(['input', 'textarea']):
                input_info = {
                    'name': input_field.get('name', ''),
                    'type': input_field.get('type', 'text'),
                    'value': input_field.get('value', '')
                }
                form_info['inputs'].append(input_info)
                
            self.forms.append(form_info)
    
    def scan_xss_vulnerabilities(self):
        """Scan for potential XSS vulnerabilities in forms"""
        print("\nScanning for XSS vulnerabilities...")
        xss_payloads = [
            '<script>alert("XSS")</script>',
            '"><script>alert("XSS")</script>',
            '"><img src=x onerror=alert("XSS")>',
            '"><svg/onload=alert("XSS")>'
        ]
        
        for form in self.forms:
            print(f"Checking form on {form['url']}")
            
            # Try each XSS payload
            for payload in xss_payloads:
                # Create data dict for the form submission
                data = {}
                for input_field in form['inputs']:
                    # Skip hidden, submit, button fields
                    if input_field['type'] in ['hidden', 'submit', 'button']:
                        continue
                    
                    # Use the payload for text/password fields
                    if input_field['type'] in ['text', 'password', ''] or input_field['type'] is None:
                        data[input_field['name']] = payload
                    else:
                        data[input_field['name']] = input_field['value']
                
                # For GET requests, only simulate and report
                if form['method'] == 'get':
                    query_string = '&'.join([f"{k}={urllib.parse.quote(v)}" for k, v in data.items()])
                    test_url = f"{form['action']}?{query_string}"
                    
                    print(f"[Simulated] Testing GET with XSS payload: {test_url}")
                    self.vulnerabilities.append({
                        'type': 'Potential XSS (GET)',
                        'url': form['url'],
                        'details': f"Form action {form['action']} allows potentially malicious input via GET"
                    })
                
                # For POST requests, only simulate and report
                else:
                    print(f"[Simulated] Testing POST with XSS payload to {form['action']}")
                    self.vulnerabilities.append({
                        'type': 'Potential XSS (POST)',
                        'url': form['url'],
                        'details': f"Form allows potentially malicious input via POST to {form['action']}"
                    })
    
    def scan_sqli_vulnerabilities(self):
        """Scan for potential SQL injection vulnerabilities"""
        print("\nScanning for SQL Injection vulnerabilities...")
        
        sqli_payloads = [
            "' OR '1'='1",
            "\" OR \"1\"=\"1",
            "' OR '1'='1' --",
            "'; DROP TABLE users; --"
        ]
        
        for form in self.forms:
            print(f"Checking form on {form['url']}")
            
            # Try each SQLi payload
            for payload in sqli_payloads:
                # Create data dict for the form submission
                data = {}
                for input_field in form['inputs']:
                    # Skip non-text fields
                    if input_field['type'] not in ['text', 'password', '', None]:
                        continue
                    
                    # Use the payload for the field
                    data[input_field['name']] = payload
                
                # Only simulate the request for demonstration
                if form['method'] == 'get':
                    test_url = f"{form['action']}?{urllib.parse.urlencode(data)}"
                    print(f"[Simulated] Testing GET with SQLi payload: {test_url}")
                else:
                    print(f"[Simulated] Testing POST with SQLi payload to {form['action']}")
                
                # Add potential vulnerability
                self.vulnerabilities.append({
                    'type': 'Potential SQL Injection',
                    'url': form['url'],
                    'details': f"Form input might be vulnerable to SQL Injection"
                })
    
    def check_security_headers(self):
        """Check for missing security headers"""
        print("\nChecking security headers...")
        
        important_headers = {
            'Strict-Transport-Security': 'Missing HSTS header',
            'Content-Security-Policy': 'Missing CSP header',
            'X-Content-Type-Options': 'Missing X-Content-Type-Options header',
            'X-Frame-Options': 'Missing X-Frame-Options header',
            'X-XSS-Protection': 'Missing X-XSS-Protection header'
        }
        
        for url in self.visited_urls:
            try:
                response = requests.get(url, timeout=5)
                
                for header, message in important_headers.items():
                    if header not in response.headers:
                        self.vulnerabilities.append({
                            'type': 'Missing Security Header',
                            'url': url,
                            'details': message
                        })
                        print(f"{url}: {message}")
            
            except requests.RequestException:
                pass
    
    def report_vulnerabilities(self):
        """Generate a report of all found vulnerabilities"""
        if not self.vulnerabilities:
            print("\nNo vulnerabilities found.")
            return
            
        print("\n==== Vulnerability Report ====")
        print(f"Target: {self.base_url}")
        print(f"Scan Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Total Vulnerabilities: {len(self.vulnerabilities)}")
        
        # Group vulnerabilities by type
        vuln_types = {}
        for vuln in self.vulnerabilities:
            if vuln['type'] not in vuln_types:
                vuln_types[vuln['type']] = []
            vuln_types[vuln['type']].append(vuln)
            
        # Print summary by type
        for vuln_type, vulns in vuln_types.items():
            print(f"\n{vuln_type}: {len(vulns)} instances")
            for vuln in vulns[:3]:  # Limit to 3 examples per type
                print(f"  - {vuln['url']}: {vuln['details']}")
            
            if len(vulns) > 3:
                print(f"  - ... and {len(vulns) - 3} more instances")


# ---- 2. Password Strength Checker ----

class PasswordChecker:
    """Check password strength against common vulnerabilities"""
    
    def __init__(self):
        """Initialize with common password lists"""
        # Most common passwords (normally this would be a much larger list)
        self.common_passwords = [
            "123456", "password", "123456789", "12345678", "12345",
            "qwerty", "1234567", "111111", "1234567890", "123123",
            "admin", "letmein", "welcome", "monkey", "login", 
            "abc123", "starwars", "123qwe", "dragon", "passw0rd"
        ]
        
        # Common password patterns
        self.patterns = [
            r'^[0-9]+$',  # Only numbers
            r'^[a-z]+$',  # Only lowercase
            r'^[A-Z]+$',  # Only uppercase
            r'^[a-z0-9]+$',  # Only lowercase and numbers
            r'^[a-zA-Z]+$',  # Only letters
            r'^[a-zA-Z0-9]+$',  # Only alphanumeric
            r'^.*password.*$',  # Contains "password"
            r'^.*123.*$',  # Contains "123"
        ]
    
    def check_strength(self, password):
        """Check password strength and return score and feedback"""
        score = 100
        feedback = []
        
        # Check length
        if len(password) < 8:
            score -= 25
            feedback.append("Too short (< 8 chars)")
        elif len(password) < 12:
            score -= 10
            feedback.append("Could be longer (< 12 chars)")
            
        # Check if it's in common passwords list
        if password.lower() in self.common_passwords:
            score -= 50
            feedback.append("Common password, easily guessed")
            
        # Check for common patterns
        for pattern in self.patterns:
            if re.match(pattern, password):
                score -= 25
                feedback.append("Uses a common pattern")
                break
                
        # Check complexity
        has_upper = any(c.isupper() for c in password)
        has_lower = any(c.islower() for c in password)
        has_digit = any(c.isdigit() for c in password)
        has_special = any(not c.isalnum() for c in password)
        
        complexity_count = sum([has_upper, has_lower, has_digit, has_special])
        
        if complexity_count <= 1:
            score -= 40
            feedback.append("Missing character types (upper, lower, digit, special)")
        elif complexity_count <= 2:
            score -= 25
            feedback.append("Should use more character types")
        elif complexity_count <= 3:
            score -= 10
            feedback.append("Could use all character types")
            
        # Check for repeating characters
        if any(password[i] == password[i+1] for i in range(len(password)-1)):
            score -= 10
            feedback.append("Contains repeating characters")
            
        # Normalize score
        score = max(0, min(score, 100))
        
        # Generate strength label
        if score >= 80:
            strength = "Strong"
        elif score >= 60:
            strength = "Moderate"
        elif score >= 40:
            strength = "Weak"
        else:
            strength = "Very Weak"
            
        return {
            'score': score,
            'strength': strength,
            'feedback': feedback
        }


# ---- 3. File Integrity Monitor ----

class FileIntegrityMonitor:
    """Monitor files for changes by comparing hash values"""
    
    def __init__(self, directory="."):
        """Initialize with target directory to monitor"""
        self.directory = directory
        self.baseline = {}
        self.algorithm = "sha256"
    
    def calculate_file_hash(self, filepath):
        """Calculate hash of a file"""
        h = hashlib.new(self.algorithm)
        
        try:
            with open(filepath, 'rb') as f:
                # Read in chunks for large files
                chunk = f.read(8192)
                while chunk:
                    h.update(chunk)
                    chunk = f.read(8192)
                    
            return h.hexdigest()
        except (IOError, OSError):
            return None
    
    def create_baseline(self, file_patterns=None):
        """Create baseline hashes for files in directory"""
        print(f"Creating baseline hashes for files in '{self.directory}'...")
        self.baseline = {}
        
        # If file patterns is not specified, use all files
        if file_patterns is None:
            file_patterns = ['*']
            
        # Convert file patterns to regex
        pattern_regexes = []
        for pattern in file_patterns:
            # Convert glob pattern to regex
            regex = pattern.replace('.', '\\.').replace('*', '.*').replace('?', '.')
            pattern_regexes.append(re.compile(f"^{regex}$"))
        
        # Walk through directory and calculate hashes
        for root, _, files in os.walk(self.directory):
            for file in files:
                # Check if file matches any pattern
                if not any(pattern.match(file) for pattern in pattern_regexes):
                    continue
                    
                filepath = os.path.join(root, file)
                file_hash = self.calculate_file_hash(filepath)
                
                if file_hash:
                    rel_path = os.path.relpath(filepath, self.directory)
                    self.baseline[rel_path] = {
                        'hash': file_hash,
                        'last_modified': os.path.getmtime(filepath),
                        'size': os.path.getsize(filepath)
                    }
        
        print(f"Baseline created with {len(self.baseline)} files")
        return self.baseline
    
    def check_integrity(self):
        """Check current files against baseline for changes"""
        if not self.baseline:
            print("No baseline exists. Create a baseline first.")
            return []
            
        print("Checking file integrity against baseline...")
        changes = []
        
        # Check existing files for changes
        for root, _, files in os.walk(self.directory):
            for file in files:
                filepath = os.path.join(root, file)
                rel_path = os.path.relpath(filepath, self.directory)
                
                if rel_path in self.baseline:
                    # Calculate current hash
                    current_hash = self.calculate_file_hash(filepath)
                    
                    if current_hash and current_hash != self.baseline[rel_path]['hash']:
                        changes.append({
                            'file': rel_path,
                            'type': 'modified',
                            'details': f"Hash changed: {self.baseline[rel_path]['hash']} -> {current_hash}"
                        })
                else:
                    # New file
                    changes.append({
                        'file': rel_path,
                        'type': 'new',
                        'details': 'File did not exist in baseline'
                    })
        
        # Check for deleted files
        for rel_path in self.baseline:
            filepath = os.path.join(self.directory, rel_path)
            if not os.path.exists(filepath):
                changes.append({
                    'file': rel_path,
                    'type': 'deleted',
                    'details': 'File no longer exists'
                })
        
        print(f"Found {len(changes)} changes")
        return changes


# ---- Demo ----

def demonstrate_vulnerability_assessment():
    print("===== VULNERABILITY ASSESSMENT DEMO =====\n")
    
    # 1. Web Vulnerability Scanner (simulation only)
    print("1. Web Vulnerability Scanner Demo")
    print("Note: We'll only simulate scanning to avoid any actual testing")
    
    # Target URL for demonstration (use a test site, not production)
    scanner = WebVulnScanner("https://example.com", max_urls=3)
    scanner.crawl(max_depth=1)
    scanner.scan_xss_vulnerabilities()
    scanner.scan_sqli_vulnerabilities()
    scanner.check_security_headers()
    scanner.report_vulnerabilities()
    print("")
    
    # 2. Password Strength Checker
    print("2. Password Strength Checker Demo")
    checker = PasswordChecker()
    
    test_passwords = [
        "password123",
        "P@ssw0rd!",
        "qwerty",
        "iLoveSecurity2023!",
        "12345678"
    ]
    
    for password in test_passwords:
        result = checker.check_strength(password)
        print(f"\nPassword: {password}")
        print(f"Strength: {result['strength']} ({result['score']}/100)")
        print(f"Feedback: {', '.join(result['feedback']) if result['feedback'] else 'No issues found'}")
    
    print("")
    
    # 3. File Integrity Monitor
    print("3. File Integrity Monitor Demo")
    # Use the current directory for the demo
    monitor = FileIntegrityMonitor(".")
    
    # Create baseline
    baseline = monitor.create_baseline([".py"])  # Only monitor Python files
    
    # Simulate a file change
    demo_file = "integrity_test.txt"
    with open(demo_file, 'w') as f:
        f.write("Original content for integrity test")
    
    # Create a new baseline including our test file
    monitor.create_baseline()
    
    # Modify the file
    time.sleep(1)  # Ensure the timestamp changes
    with open(demo_file, 'w') as f:
        f.write("Modified content to test integrity checking")
    
    # Check integrity
    changes = monitor.check_integrity()
    
    # Clean up test file
    if os.path.exists(demo_file):
        os.remove(demo_file)


if __name__ == "__main__":
    demonstrate_vulnerability_assessment()
